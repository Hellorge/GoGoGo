package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"gogogo/modules"
	"html/template"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

type PageContent struct {
	Content   template.HTML
	Style     template.CSS
	Script    template.JS
	IsSPAMode bool
}

var (
	templates     = make(map[string]*template.Template)
	templateMutex sync.RWMutex

	projectRoot = ".."

	config          = *modules.Cfg
	Cache           *modules.Cache
	Coalescer       *modules.Coalescer
	buildRouter     *modules.Router
	findAndReadFile func(string, string) ([]byte, error)
	findAndReadTemp func(string, string) ([]byte, error)
	staticHandler   http.Handler
)

func main() {
	if err := os.Chdir(projectRoot); err != nil {
		fmt.Printf("Error changing to project root directory: %v\n", err)
		os.Exit(1)
	}

	flag.Parse()

	server, err := NewServer(config)
	if err != nil {
		log.Fatalf("Failed to create server: %v", err)
	}

	if config.MetricsEnabled {
		modules.SetupMetricsAPI()
		server = modules.MetricsMiddleware(server)
	}

	addr := fmt.Sprintf("%s:%d", config.ServerHost, config.ServerPort)

	fmt.Printf("Server starting on %s", addr)
	log.Fatal(http.ListenAndServe(addr, server))
}

func NewServer(config modules.Config) (http.Handler, error) {
	mux := http.NewServeMux()

	if config.CachingEnabled {
		Cache = modules.NewCache(100000)
	}

	if config.CoalescerEnabled {
		Coalescer = modules.NewCoalescer()
	}

	if config.ProductionMode {
		fmt.Println("Running in production mode")
		findAndReadFile = fnrProd
		findAndReadTemp = fnrProd
		// staticHandler = http.FileServer(BuildFileSystem{root: config.BuildDistDir})

		var err error
		buildRouter, err = modules.NewRouter(config.BuildMetaDir + "/build_trie.bin")
		if err != nil {
			return nil, fmt.Errorf("failed to create build router: %w", err)
		}
	} else {
		fmt.Println("Running in development mode")
		findAndReadFile = fnrDev
		findAndReadTemp = fnrTemp
		// staticHandler = http.FileServer(http.Dir(config.StaticDir))
	}

	if _, err := loadTemplate("", config.TemplatesMain); err != nil {
		return nil, fmt.Errorf("failed to load main template: %v", err)
	}

	mux.HandleFunc("/", webHandler)
	mux.HandleFunc("/api/", jsonHandler)
	// mux.Handle(config.StaticURLPrefix, http.StripPrefix(config.StaticURLPrefix, staticHandler))

	if config.SPAMode {
		mux.HandleFunc(config.SPAPrefix, jsonHandler)
	}

	return mux, nil
}

func fnrProd(path, filename string) ([]byte, error) {
	cacheKey := filepath.Join(path, filename)
	return Coalescer.Do(cacheKey, func() ([]byte, error) {
		// Try to get from cache first
		if value, ok := Cache.Get(cacheKey); ok {
			return value, nil
		}

		// If not in cache, try to get from build router
		filePath, ok := buildRouter.Route(cacheKey)

		if !ok {
			return nil, fmt.Errorf("file not found: %s", cacheKey)
		}

		content, err := os.ReadFile(filePath)
		if err != nil {
			return nil, fmt.Errorf("error reading file %s: %w", filePath, err)
		}

		// Cache the content we just read
		Cache.Set(cacheKey, content, time.Now().Add(24*time.Hour))

		return content, nil
	})
}

func fnrDev(path, filename string) ([]byte, error) {
	fullPath := filepath.Join(config.BaseDir, path, filename)

	return os.ReadFile(fullPath)
}

func loadContent(path string) (PageContent, error) {
	content, err := findAndReadFile(path, "content.html")
	if err != nil {
		return PageContent{}, fmt.Errorf("content file error: %w", err)
	}

	style, _ := findAndReadFile(path, "style.css")
	script, _ := findAndReadFile(path, "script.js")

	return PageContent{
		Content:   template.HTML(content),
		Style:     template.CSS(style),
		Script:    template.JS(script),
		IsSPAMode: *&config.SPAMode,
	}, nil
}

func loadTemplate(dir string, name string) (*template.Template, error) {
	tmpl_key := filepath.Join(dir, name)

	templateMutex.RLock()
	tmpl, ok := templates[tmpl_key]
	templateMutex.RUnlock()
	if ok {
		return tmpl, nil
	}

	templateMutex.Lock()
	defer templateMutex.Unlock()

	content, err := findAndReadTemp(dir, name)
	if err != nil {
		return nil, fmt.Errorf("error reading template file: %w", err)
	}

	tmpl, err = template.New(tmpl_key).Parse(string(content))
	if err != nil {
		return nil, fmt.Errorf("error parsing template: %w", err)
	}

	templates[tmpl_key] = tmpl
	return tmpl, nil
}

func fnrTemp(path, filename string) ([]byte, error) {
	fullPath := filepath.Join(config.AppFilesDir, path, filename)

	return os.ReadFile(fullPath)
}

func webHandler(w http.ResponseWriter, r *http.Request) {
	path := normalizePath(r.URL.Path)
	content, err := loadContent(path)
	if err != nil {
		http.Error(w, "Page not found", http.StatusNotFound)
		return
	}

	tmpl, err := loadTemplate("", config.TemplatesMain)
	if err != nil {
		http.Error(w, "Internal server error", http.StatusInternalServerError)
		return
	}

	if err := tmpl.Execute(w, content); err != nil {
		log.Printf("Error executing template: %v", err)
	}
}

func jsonHandler(w http.ResponseWriter, r *http.Request) {
	path := strings.TrimPrefix(r.URL.Path, "/api")
	path = normalizePath(strings.TrimPrefix(path, config.SPAPrefix))
	content, err := loadContent(path)
	if err != nil {
		http.Error(w, "Page not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(content); err != nil {
		log.Printf("Error encoding JSON: %v", err)
	}
}

func normalizePath(path string) string {
	if path == "/" || path == "" {
		return "home"
	}
	return strings.TrimPrefix(path, "/")
}
