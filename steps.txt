steps takes for this project:

1. installed go

2. some more installs:
	- go get github.com/tdewolff/minify/v2
	- go get github.com/tdewolff/minify/v2/css
	- go get github.com/tdewolff/minify/v2/js
	- go get github.com/tdewolff/minify/v2/html
	- go get github.com/fsnotify/fsnotify
	- go get github.com/evanw/esbuild

3. commands:
	start server = go run main.go 
		- '-prod' for production mode
		- '-spa' for SPA mode

	build assets = go run build.go
		- '-watch' for file watcher to build assets on change
		- '-concurrency x' to change parallel building to no X
		- use .buildignore file to ignore patters and files in build process

+++ 
- client side page caching based on client system specs
- when building remove any cache corresponding to files that are built
- url aliases for folder and url name differentialtion
- client side background thread asset loading

- Client-side enhancements:
	Implement a state management solution (similar to Redux or MobX)
	Add client-side routing with support for nested routes
	Create a component system for reusable UI elements

- Code splitting and lazy loading:
	Implement dynamic imports for JavaScript modules
	Create a system for lazy-loading page components

- Server-side rendering (SSR):
	Implement initial SSR for faster first contentful paint
	Add support for SSR of dynamic routes

- API development features:
	Create a robust routing system with support for RESTful and GraphQL APIs
	Implement middleware support for request/response processing
	Add built-in support for database ORM (like GORM)

- Developer experience:
	Implement hot module replacement for faster development
	Create a CLI tool for scaffolding new projects and components
	Add support for TypeScript on the client-side

- Testing and debugging:
	Implement a testing framework for both client and server
	Add built-in support for logging and error tracking

- Performance optimizations:
	Implement automatic image optimization
	Add support for service workers and Progressive Web App (PWA) features

- Security enhancements:
	Implement CSRF protection
	Add built-in rate limiting
	Provide easy-to-use authentication and authorization modules

- Internationalization (i18n) and localization (l10n):
	Add support for multi-language content
	Implement locale-based formatting for dates, numbers, etc.

- Documentation and examples:
	Create comprehensive documentation
	Develop a set of example projects showcasing various use cases 


- Asynchronous file reading:
For large files or when serving multiple requests simultaneously, we could implement asynchronous file reading. This would allow the server to handle other requests while waiting for file I/O operations to complete.
- Improved template parsing:
The current template system parses templates on each request in development mode. We could implement a more sophisticated template parsing system that watches for file changes and only re-parses templates when necessary, even in development mode.
- Request middleware:
Implementing a middleware system would allow for more flexible request processing, such as logging, authentication, or custom headers. This could be especially useful for API endpoints.
- Enhanced SPA support:
We could expand the SPA support by implementing features like client-side routing helpers, state management integration, or server-side rendering for initial SPA loads to improve SEO and initial load times.
- Configuration management:
Instead of using command-line flags for configuration, we could implement a more robust configuration system using environment variables or configuration files. This would make it easier to manage different environments (development, staging, production) and allow for more granular control over the framework's behavior.
- Improved error handling and logging:
Implementing a centralized error handling and logging system would make it easier to debug issues and monitor the application's health in production.
- Performance profiling:
Adding built-in performance profiling tools would help identify bottlenecks and optimize the framework's performance over time.
- Testing suite:
Developing a comprehensive testing suite, including unit tests and integration tests, would ensure the framework's reliability and make it easier to contribute to the project.
- Documentation and examples:
Creating detailed documentation and example applications would help developers understand and use the framework effectively.